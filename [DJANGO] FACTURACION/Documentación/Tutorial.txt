=======================================================================
üöÄ PRIMEROS PASOS CON DJANGO: CONSTRUYENDO UN SISTEMA DE FACTURACI√ìN üöÄ
=======================================================================

¬°Buenas! Vamos a arrancar con el proyecto de facturaci√≥n. Te voy a guiar paso a paso como si estuvi√©ramos codeando juntos, con mate de por medio, claro. üßâ


PASO 1: Dar a luz el proyecto üöÄ
================================

Comando ejecutado:
-----------------

	django-admin startproject FACTURACION

Explicaci√≥n detallada:
---------------------

¬°Ac√° estamos creando el esqueleto de nuestra aplicaci√≥n! ü¶¥ El comando django-admin startproject FACTURACION le dice a Django: "Che, haceme el favor de crear un nuevo proyecto con el nombre FACTURACION". Django autom√°ticamente genera una carpeta con ese nombre y, dentro, un mont√≥n de archivos clave que necesitamos para que todo funcione. Es como tener los cimientos de la casa antes de empezar a levantar las paredes. Es importante porque nos ahorra tener que crear toda esta estructura de carpetas y archivos a mano, que es un mont√≥n y es f√°cil pifiarla. üìÅ

Estructura de carpetas despu√©s del paso:
---------------------------------------

Despu√©s de ejecutar este comando, tu √°rbol de directorios se va a ver as√≠. Fijate que el comando se ejecuta desde el lugar donde quer√©s que viva el proyecto:

. (Directorio donde ejecutaste el comando, por ej: /home/usuario/proyectos/)
‚îî‚îÄ‚îÄ FACTURACION/
    ‚îú‚îÄ‚îÄ manage.py
    ‚îî‚îÄ‚îÄ FACTURACION/          # <--- Este es el paquete de Python de nuestro proyecto.
        ‚îú‚îÄ‚îÄ __init__.py
        ‚îú‚îÄ‚îÄ settings.py
        ‚îú‚îÄ‚îÄ urls.py
        ‚îî‚îÄ‚îÄ wsgi.py

Consejo/curiosidad:
------------------

¬øSab√≠as que pod√©s usar guiones bajos en los nombres de los proyectos, como mi_proyecto_facturacion? Django lo permite, pero despu√©s ten√©s que tener cuidado al importar cosas porque los guiones medios (mi-proyecto) no son v√°lidos en Python. Siempre es buena pr√°ctica usar nombres que sean tambi√©n identificadores v√°lidos de Python. Yo prefiero usar may√∫sculas para el nombre del proyecto, como hicimos ac√°, o usar guiones bajos. ¬°Eso ya va en gustos! üòâ


PASO 2: Entrando a la cancha ‚öΩ
===============================

Comando ejecutado:
-----------------

	cd FACTURACION

Explicaci√≥n detallada:
---------------------

Con cd FACTURACION (Change Directory) nos estamos metiendo adentro de la carpeta ra√≠z del proyecto que acabamos de crear. Es como agarrar la llave, abrir la puerta de nuestra nueva casa y poner un pie adentro. üö™ Ahora estamos posicionados en el lugar correcto para empezar a correr los comandos propios de Django, como manage.py. Es importante porque casi todas las tareas que hagamos de ahora en m√°s (crear aplicaciones, correr el servidor, etc.) las vamos a ejecutar desde ac√° adentro. Si no lo hacemos, los comandos no van a encontrar la configuraci√≥n del proyecto y nos van a saltar errores. üí•

Estructura de carpetas despu√©s del paso:
---------------------------------------

La estructura es la misma, ¬°pero ahora estamos parados adentro! üòÑ La terminal ahora muestra que estamos en .../FACTURACION$. O sea, nuestro "directorio de trabajo" ahora es la carpeta ra√≠z.

. (Directorio donde ejecutaste el comando, por ej: /home/usuario/proyectos/)
‚îî‚îÄ‚îÄ FACTURACION/                <--- ¬°ESTAMOS AC√Å ADENTRO! üìç
    ‚îú‚îÄ‚îÄ manage.py
    ‚îî‚îÄ‚îÄ FACTURACION/
        ‚îú‚îÄ‚îÄ __init__.py
        ‚îú‚îÄ‚îÄ settings.py
        ‚îú‚îÄ‚îÄ urls.py
        ‚îî‚îÄ‚îÄ wsgi.py

Consejo/curiosidad:
------------------

Si en cualquier momento te olvid√°s d√≥nde est√°s parado, us√° pwd (Print Working Directory) en Linux/macOS o cd sin argumentos en Windows para mostrar la ruta actual. Y si quer√©s ver qu√© hay en la carpeta, us√° ls (Linux/macOS) o dir (Windows). ¬°Nunca est√° de m√°s orientarse! üß≠


PASO 3: Argentinizando el asunto üá¶üá∑
===================================

Comando ejecutado:
-----------------

No es un comando, editamos el archivo FACTURACION/settings.py con nuestro editor favorito (VS Code, Sublime, Vim, el que sea).

Explicaci√≥n detallada:
---------------------

Estamos tocando el coraz√≥n de la configuraci√≥n de nuestro proyecto: el settings.py. Ac√° le decimos a Django c√≥mo queremos que se comporte. Al cambiar LANGUAGE_CODE a 'es-ar' le estamos pidiendo que los mensajes autom√°ticos del sistema (como los de error del admin) nos los muestre en espa√±ol de Argentina. ¬°Chau "Invalid form", hola "Formulario inv√°lido"! üôå Y al poner TIME_ZONE en 'America/Argentina/Buenos_Aires' nos aseguramos de que todas las operaciones con fechas y horas (como la de una factura, por ejemplo) se guarden y muestren en nuestro huso horario. Es fundamental para no descontar facturas a las 3 de la tarde cuando ac√° son las 3 de la ma√±ana. üòâ

C√≥digo modificado (con comentarios):
-----------------------------------

	# ‚úèÔ∏èMODIFICACI√ìN: Cambio de idioma a Espa√±ol Argentina üßâ
	# Original: LANGUAGE_CODE = 'en-us'
	LANGUAGE_CODE = 'es-ar'

	# ‚úèÔ∏èMODIFICACI√ìN: Ajuste de zona horaria a Argentina üïí
	# Original: TIME_ZONE = 'UTC'
	TIME_ZONE = 'America/Argentina/Buenos_Aires'


	USE_I18N = True

	USE_TZ = True

	# ... (resto del c√≥digo)

	# ========================================================== #
	# üßâ EXPLICACI√ìN: Con estos cambios, logramos que el sistema
	# hable en nuestro idioma y respete nuestro horario.
	# Fundamental para un sistema de facturaci√≥n argentino.
	# ========================================================== #

Estructura de carpetas despu√©s del paso:
---------------------------------------

¬°La estructura de carpetas no cambia! Pero el archivo settings.py ahora tiene nuestra config personalizada.

FACTURACION/
‚îú‚îÄ‚îÄ manage.py
‚îî‚îÄ‚îÄ FACTURACION/
    ‚îú‚îÄ‚îÄ __init__.py
    ‚îú‚îÄ‚îÄ settings.py          <--- (archivo modificado).
    ‚îú‚îÄ‚îÄ urls.py
    ‚îî‚îÄ‚îÄ wsgi.py

Consejo/curiosidad:
------------------

Adem√°s de es-ar, pod√©s probar otros c√≥digos como es-mx o en-us para ver c√≥mo cambia el idioma. Sobre la zona horaria, es buena pr√°ctica usar siempre la zona por regi√≥n/ciudad (como hicimos) en lugar de usar un offset fijo como '-03:00', porque Django entiende y maneja autom√°ticamente los cambios por horario de verano si los hubiera (aunque en gran parte de Argentina no se usa, igual es m√°s correcto).


PASO 4: Prendemos los motores üèÅ
================================

Comando ejecutado:
-----------------

	python manage.py runserver

(En algunas instalaciones, si ten√©s Python 3 como √∫nico, puede ser python3 manage.py runserver).

Explicaci√≥n detallada:
---------------------

¬°Este es el momento de la verdad! Con python manage.py runserver le estamos diciendo a Django: "Dale, levant√° el servidor de desarrollo que viene inclu√≠do". üöÄ Este servidor liviano nos permite ver nuestra aplicaci√≥n en el navegador mientras la estamos construyendo. Cada vez que guardemos un cambio en el c√≥digo, se va a reiniciar solo (aunque a veces hay que darle un toque, sobre todo al agregar archivos nuevos). Es important√≠simo para poder ir viendo el progreso en tiempo real sin tener que montar un servidor web como Apache o Nginx. Vas a ver una salida en la terminal que dice algo como Starting development server at http://127.0.0.1:8000/. Si abr√≠s esa direcci√≥n en tu navegador, ¬°vas a ver la p√°gina de bienvenida de Django con el cohete despegando! üöÄ

Estructura de carpetas despu√©s del paso:
---------------------------------------

La estructura de carpetas sigue igual. El servidor no crea archivos nuevos en tu proyecto.

FACTURACION/
‚îú‚îÄ‚îÄ manage.py
‚îî‚îÄ‚îÄ FACTURACION/
    ‚îú‚îÄ‚îÄ __init__.py
    ‚îú‚îÄ‚îÄ settings.py
    ‚îú‚îÄ‚îÄ urls.py
    ‚îî‚îÄ‚îÄ wsgi.py

Consejo/curiosidad:
------------------

Por defecto, el servidor corre en el puerto 8000. Si por alg√∫n motivo ese puerto est√° ocupado, pod√©s cambiarlo f√°cil. Por ejemplo, para usar el puerto 8080, el comando ser√≠a python manage.py runserver 8080. Tambi√©n pod√©s hacer que escuche en todas las interfaces de red de tu PC para que otros dispositivos de la misma red (como tu celular) puedan acceder, usando python manage.py runserver 0.0.0.0:8000. ¬°Ojo! Esto es solo para desarrollo, no para producci√≥n. üî•


PASO 5: Creando al primer ser en nuestra base de datos üßô‚Äç‚ôÇÔ∏è
=========================================================

¬°Sigamos con la movida! Ya tenemos el servidor corriendo y el proyecto argentinizado. Ahora vamos a crear al primer habitante de nuestro sistema: el superusuario. üë§ (All Mighty User ü¶∏).

Comando ejecutado:
-----------------

	python manage.py createsuperuser

Explicaci√≥n detallada:
---------------------

ste comando es como el "h√°gase la luz" de nuestro proyecto. üí° Lo que hace es crear un usuario con poderes absolutos dentro del sistema. Un superusuario puede entrar al panel de administraci√≥n y hacer literalmente cualquier cosa: crear, modificar y borrar cualquier registro de cualquier tabla. Es el administrador total, el que tiene la sart√©n por el mango. üç≥ Es importante porque sin un superusuario no podr√≠amos acceder al panel de admin, y el panel de admin es una de las herramientas m√°s piolas que tiene Django para manejar los datos de nuestra aplicaci√≥n sin tener que programar una interfaz desde cero.

Lo que se ve en pantalla durante la creaci√≥n:
--------------------------------------------

Cuando ejecut√°s el comando, la terminal te va a guiar paso a paso. Ac√° te muestro c√≥mo ser√≠a la interacci√≥n:

	python manage.py createsuperuser
	Nombre de usuario (leave blank to use 'tu_usuario'): admin
	Direcci√≥n de correo electr√≥nico: admin@example.com
	Password: ‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢   (cuando escrib√≠s la contrase√±a, no se ve nada por seguridad)
	Password (again): ‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢
	Superuser created successfully.

Detalles importantes:
--------------------

- Nombre de usuario: Ponemos admin (f√°cil de recordar).

- Email: Podemos poner uno ficticio por ahora, como admin@example.com.

- Contrase√±a: Ac√° va la magia. Cuando escrib√≠s cthulhu2026 (o la que quieras), la terminal no muestra ni asteriscos para que nadie de afuera pueda ver cu√°ntos caracteres tiene tu contrase√±a. Es normal, no est√° trabada, est√° escribiendo pero en modo sigilo. ü§´

- Django te va a avisar si la contrase√±a es muy com√∫n o muy corta, pero te deja seguir igual (le decimos que s√≠ con 'y').

Estructura del proyecto despu√©s del paso:
----------------------------------------

¬°Ac√° viene un concepto clave! La estructura de carpetas de nuestro proyecto no cambia en absoluto. Pero en la base de datos (que por ahora es el archivo db.sqlite3 que Django crea autom√°ticamente al hacer la primera migraci√≥n), se agreg√≥ un registro en la tabla auth_user. Es decir, el cambio no est√° a la vista en los archivos, sino en la base de datos. üì¶

FACTURACION/
‚îú‚îÄ‚îÄ db.sqlite3                 <--- ¬°Apareci√≥ este archivo! (la base de datos).
‚îú‚îÄ‚îÄ manage.py
‚îî‚îÄ‚îÄ FACTURACION/
    ‚îú‚îÄ‚îÄ __init__.py
    ‚îú‚îÄ‚îÄ settings.py
    ‚îú‚îÄ‚îÄ urls.py
    ‚îî‚îÄ‚îÄ wsgi.py

Consejo/curiosidad:
------------------

Si quer√©s ver el registro que se cre√≥ sin entrar al admin (todav√≠a), pod√©s usar el comando python manage.py shell para abrir una consola interactiva de Django y consultar la base de datos. Ser√≠a algo as√≠:

	from django.contrib.auth.models import User
	user = User.objects.get(username='admin')
	print(user.email, user.is_superuser)


PASO 6: Entrando al centro de comando üéÆ
========================================

Comando ejecutado:
-----------------

Abrir el navegador y navegar a: http://127.0.0.1:8000/admin
(Asegurate de tener el servidor corriendo con python manage.py runserver).

Explicaci√≥n detallada:
---------------------

¬°Llegamos al sanctasanct√≥rum! El panel de administraci√≥n de Django es una de sus caracter√≠sticas m√°s famosas y queridas. Es un interfaz web completamente funcional que Django te regala sin que escribas una sola l√≠nea de c√≥digo (bueno, casi). Ac√° vas a poder gestionar todos los modelos (tablas) que vayas creando en tus aplicaciones. Es como tener un "Excel" pero mucho m√°s copado y conectado directamente a tu base de datos. üìä

Descripci√≥n del panel una vez que entr√°s:
----------------------------------------

1. Al entrar a http://127.0.0.1:8000/admin, te aparece una pantalla de login. Pon√©s las credenciales que creaste en el paso 5: usuario admin, contrase√±a cthulhu2026. üîë

2. Despu√©s de loguearte, ves la p√°gina principal del admin. Por defecto (sin ninguna app nuestra creada), vas a ver una sola secci√≥n llamada Autenticaci√≥n y Autorizaci√≥n (o algo similar en ingl√©s si no te tomaste el tiempo de cambiar el idioma en el paso 3, ¬°pero nosotros lo cambiamos! as√≠ que estar√° en espa√±ol). üá¶üá∑

3. Dentro de esa secci√≥n, hay dos enlaces:

+ Usuarios: Ac√° pod√©s ver y editar todos los usuarios registrados. Si entr√°s, vas a encontrar a nuestro amigo admin que acabamos de crear. üë§

+ Grupos: Sirve para organizar permisos, pero por ahora no lo vamos a tocar.

El panel tiene un dise√±o limpio y funcional. Arriba a la derecha, un bot√≥n para cambiar la contrase√±a y otro para cerrar sesi√≥n. Es intuitivo y f√°cil de navegar. üß≠

¬øPor qu√© es importante el superusuario y el panel de administraci√≥n?
--------------------------------------------------------------------

- Para hacer pruebas: Mientras desarrollamos, podemos crear datos de prueba (clientes, productos, etc.) directamente desde el admin sin tener que escribir c√≥digo o SQL. ‚ö°

- Para gestionar el sistema: En producci√≥n, pod√©s tener usuarios "staff" que entren al admin a cargar facturas, gestionar clientes, etc. Es un backend administrativo completo.

- Para entender el modelo de datos: El admin te muestra c√≥mo Django ve tus datos, y te permite interactuar con ellos de manera visual. Es una gran herramienta de aprendizaje y depuraci√≥n. üêõ

- El superusuario es la llave maestra: Sin √©l, no podr√≠as entrar al admin ni ejecutar ciertos comandos que requieren permisos especiales. Es el primer usuario que necesit√°s para arrancar a poblar el sistema.

Consejo/curiosidad:
------------------

Fijate que el admin ya viene en espa√±ol (si hicimos bien el paso 3). ¬°Qu√© placer ver "Usuarios" en lugar de "Users"! üòç Adem√°s, si quer√©s personalizar c√≥mo se ven tus modelos en el admin (qu√© campos mostrar, c√≥mo ordenarlos, etc.), despu√©s vas a poder hacerlo creando archivos admin.py en tus aplicaciones.


PASO 7: Nace la app de productos üè≠
===================================

Vamos a crear nuestra primera aplicaci√≥n dentro del proyecto. Ac√° es donde la cosa empieza a tomar forma y dejamos de lado la teor√≠a para meternos de lleno en la l√≥gica de nuestro facturador. üß±

Comando ejecutado:
-----------------

	python manage.py startapp productos

Explicaci√≥n detallada:
---------------------

¬°Manos a la obra! Con startapp productos le estamos diciendo a Django: "Che, creame una aplicaci√≥n nueva que se llame productos". Pero, ¬øqu√© es una app en Django? Ac√° va la analog√≠a: üè¢

Pens√° en el proyecto (FACTURACION) como una empresa grande. La empresa tiene distintos departamentos que se encargan de cosas espec√≠ficas:

+ El departamento de Productos se encarga de todo lo relacionado con los art√≠culos que se venden: su nombre, precio, stock, etc.

+ M√°s adelante podr√≠amos tener el departamento de Clientes, el de Facturaci√≥n, el de Reportes...

En Django, cada uno de esos "departamentos" es una app. Una app es un m√≥dulo de Python que encapsula un conjunto de funcionalidades relacionadas. Tiene sus propios modelos (la estructura de datos), sus vistas (la l√≥gica de negocio), sus templates (el HTML) y sus URLs. Es como un "mini-proyecto" dentro del proyecto grande, y lo mejor es que son reutilizables: si alg√∫n d√≠a hac√©s otro sistema de ventas, podr√≠as copiar y pegar la app de productos y ya ten√©s media cancha hecha. üîÑ

Estructura de carpeta despu√©s del paso:
--------------------------------------

¬°Mir√° c√≥mo creci√≥ la familia! Django nos cre√≥ una carpeta productos con todo lo necesario para empezar a desarrollar:

FACTURACION/
‚îú‚îÄ‚îÄ db.sqlite3
‚îú‚îÄ‚îÄ manage.py
‚îú‚îÄ‚îÄ FACTURACION/             	# Carpeta del proyecto (configuraci√≥n).
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ settings.py
‚îÇ   ‚îú‚îÄ‚îÄ urls.py
‚îÇ   ‚îî‚îÄ‚îÄ wsgi.py
‚îî‚îÄ‚îÄ productos/                	<--- Nuestra nueva app. üéâ
    ‚îú‚îÄ‚îÄ __init__.py
    ‚îú‚îÄ‚îÄ admin.py               	# Para configurar c√≥mo se ve en el admin.
    ‚îú‚îÄ‚îÄ apps.py               	# Configuraci√≥n de la app.
    ‚îú‚îÄ‚îÄ migrations/           	# Ac√° Django guarda los cambios de la BD.
    ‚îÇ   ‚îî‚îÄ‚îÄ __init__.py
    ‚îú‚îÄ‚îÄ models.py             	# Donde definimos las tablas (ej: Producto).
    ‚îú‚îÄ‚îÄ tests.py              	# Para probar que todo funciona.
    ‚îî‚îÄ‚îÄ views.py              	# La l√≥gica de negocio.

Consejo/curiosidad:
------------------

Fijate que Django crea el archivo apps.py con una clase que configura la app. No le des mucha bola ahora, pero es √∫til cuando quer√©s hacer configuraciones m√°s avanzadas. Tambi√©n not√° la carpeta migrations/: ¬°es una de las magias m√°s grandes de Django! Ah√≠ se van a guardar los pasos necesarios para construir y modificar la base de datos sin escribir una sola l√≠nea de SQL. ü™Ñ


PASO 8: Presentando la app en la empresa üìã
===========================================

Comando ejecutado:
-----------------

Editamos el archivo FACTURACION/settings.py para agregar nuestra app a la lista de aplicaciones instaladas.

Explicaci√≥n detallada:
---------------------

Ac√° estamos haciendo el equivalente a mandar un memo a toda la empresa diciendo: "Atenci√≥n, tenemos un nuevo departamento: Productos. A partir de ahora, cuando el sistema haga cosas, tenga en cuenta a este departamento". üì¢

Cuando agregamos 'productos' a INSTALLED_APPS, le estamos diciendo a Django: "Esta app forma parte de nuestro proyecto. Inclu√≠ sus modelos cuando hagas migraciones, mostrala en el panel de admin si corresponde, y tenela en cuenta para todo lo que sigue". Sin este paso, Django ignora ol√≠mpicamente a nuestra app, por m√°s que la carpeta exista. Es como tener un empleado al que no le pagan: est√°, pero no hace nada. üòÖ

C√≥digo modificado en settings.py:
--------------------------------

	# Application definition

	INSTALLED_APPS = [
    		'django.contrib.admin',          	# App del panel de administraci√≥n.
    		'django.contrib.auth',           	# App para manejar usuarios.
    		'django.contrib.contenttypes',   	# App para manejar tipos de contenido.
    		'django.contrib.sessions',       	# App para manejar sesiones.
    		'django.contrib.messages',      	# App para mensajes entre requests.
    		'django.contrib.staticfiles',     	# App para archivos est√°ticos (CSS, JS).

    		# ‚úèÔ∏è MODIFICACI√ìN: Agregamos nuestra primera app al proyecto.
    		# ‚ûï AGREGADO: La app 'productos' nos va a permitir gestionar
    		#   todo lo relacionado con los art√≠culos a facturar.
    		'productos',
	]

	# ============================================================ #
	# üßâ EXPLICACI√ìN: Al incluir 'productos' en INSTALLED_APPS,
	# Django reconoce oficialmente a nuestra app. Ahora cuando
	# hagamos migraciones, va a buscar models.py dentro de
	# la carpeta productos y crear√° las tablas correspondientes.
	# Adem√°s, si definimos algo en admin.py, aparecer√° en el panel.
	# ============================================================ #

Estructura de carpetas despu√©s del paso:
---------------------------------------

La estructura de archivos y carpetas no cambia. Solo modificamos el contenido de un archivo existente. Pero el cambio es profundo: ahora Django "ve" nuestra app.

FACTURACION/
‚îú‚îÄ‚îÄ db.sqlite3
‚îú‚îÄ‚îÄ manage.py
‚îú‚îÄ‚îÄ FACTURACION/
‚îÇ   ‚îî‚îÄ‚îÄ settings.py          <--- (archivo modificado).
‚îî‚îÄ‚îÄ productos/

Consejo/curiosidad:
------------------

Fijate que hay un mont√≥n de apps ya instaladas por defecto (django.contrib.admin, auth, etc.). Esas son las que vienen con Django y le dan toda la funcionalidad base. Podr√≠amos sacarlas si quisi√©ramos (por ejemplo, si no queremos usar el admin), pero son tan √∫tiles que casi siempre las dejamos. Nuestra app productos ahora est√° al mismo nivel que ellas. ü•á


PASO 9: El chequeo m√©dico del proyecto ü©∫
=========================================

Comando ejecutado:
-----------------

	python manage.py check

Explicaci√≥n detallada:
---------------------

Este comando es como ir al m√©dico para un chequeo general. üè• check examina todo tu proyecto de Django (la configuraci√≥n, las apps, los modelos que definamos despu√©s) y te avisa si encuentra alg√∫n problema sin tocar la base de datos ni ejecutar la aplicaci√≥n.

Es re √∫til porque:

+ Detecta errores comunes antes de que explote todo en producci√≥n. üí£

+ Verifica que los nombres de las apps est√©n bien escritos.

+ Chequea que no haya conflictos entre modelos.

+ Te avisa si olvidaste poner un m√©todo requerido o si hay algo raro en la configuraci√≥n.

Si todo est√° bien, no dice nada (o tira alg√∫n mensaje informativo). Si hay un error, te lo marca con colorcitos y todo para que lo corrijas. Es una red de seguridad que te salva de muchos dolores de cabeza. üòå

Lo que se ve en pantalla:
------------------------

Si hicimos todo bien (y por ahora es dif√≠cil pifiarla), la salida va a ser algo as√≠:

	python manage.py check
	System check identified no issues (0 silenced).

Ese mensajito es m√∫sica para los o√≠dos de cualquier desarrollador Django. üéµ Significa "todo en orden, pod√©s seguir tranquilo".

Si hubiera un error (por ejemplo, si hubi√©ramos escrito mal 'productos' en INSTALLED_APPS), ver√≠amos algo como:

	python manage.py check
	ModuleNotFoundError: No module named 'productosss'

Ah√≠ nos estar√≠a diciendo "che, la app 'productosss' no existe, revis√° lo que escribiste". ¬°Un salvavidas! üõü

Estructura de carpetas despu√©s del paso:
---------------------------------------

Sin cambios. El comando check es solo de verificaci√≥n, no modifica nada.

Consejo/curiosidad:
------------------

python manage.py check se ejecuta autom√°ticamente cada vez que corremos runserver (por eso a veces vemos ese mensajito cuando arrancamos el servidor). Pero es buena pr√°ctica ejecutarlo manualmente despu√©s de hacer cambios grandes en la configuraci√≥n o antes de hacer un deploy, para asegurarnos de que no metimos la pata. Tambi√©n pod√©s hacerlo m√°s espec√≠fico, por ejemplo python manage.py check productos para que revise solo esa app. üéØ


PASO 10: El nacimiento de Producto (el ADN de nuestra app) üß¨
=============================================================

¬°Uf, ac√° estamos entrando en la parte m√°s jugosa! Vamos a crear nuestro primer modelo, generar las migraciones y ver c√≥mo cobra vida en la base de datos. Preparate, porque esto es pura magia negra de Django (Gandalf, la ten√©s adentro...). üßô‚Äç‚ôÇÔ∏è‚ú®

Comando ejecutado:
-----------------

Editamos el archivo productos/models.py para definir nuestro primer modelo.

Explicaci√≥n detallada:
---------------------

Un modelo en Django es la representaci√≥n en Python de una tabla de la base de datos. Cada clase que hereda de models.Model se convierte en una tabla, y cada atributo de clase (que es una instancia de alg√∫n models.Campo) se convierte en una columna. Es como si estuvi√©ramos dibujando el plano de una casa üè†: ac√° van a ir los dormitorios (campos), ac√° el ba√±o, etc. Despu√©s, Django se encarga de construir la casa (la tabla) en la base de datos usando ese plano.

C√≥digo completo en productos/models.py:
--------------------------------------

	from django.db import models


	# Create your models here.
	class Producto(models.Model):
    
    	# Modelo que representa un producto facturable.
    	# Cada instancia de esta clase ser√° un registro en la tabla 'productos_producto'.
    
    		# ‚ûï AGREGADO: Nombre del producto (ej: "Yerba Mate Amanda").
    		nombre = models.CharField(
        		max_length=100,
        		verbose_name="Nombre del producto"
    		)
    
    		# ‚ûï AGREGADO: Descripci√≥n m√°s detallada (puede ser opcional).
    		descripcion = models.TextField(
        		blank=True,  # Puede estar vac√≠o.
        		null=True,   # Permite NULL en la BD.
        		verbose_name="Descripci√≥n"
    		)
    
    		# ‚ûï AGREGADO: Precio unitario en pesos argentinos.
    		precio = models.DecimalField(
        		max_digits=10,        # Hasta 99999999.99
        		decimal_places=2,      # Dos decimales (centavos).
        		verbose_name="Precio (ARS)"
    		)
    
    		# ‚ûï AGREGADO: Control de stock.
    		stock = models.IntegerField(
        		default=0,
        		verbose_name="Cantidad en stock"
    		)
    
    		# ‚ûï AGREGADO: Fecha de creaci√≥n (se autocompleta).
    		fecha_creacion = models.DateTimeField(
        		auto_now_add=True,
        		verbose_name="Fecha de alta"
    		)
    
    		# ‚ûï AGREGADO: Fecha de √∫ltima modificaci√≥n (se actualiza solo).
    		fecha_actualizacion = models.DateTimeField(
        		auto_now=True,
        		verbose_name="√öltima modificaci√≥n"
    		)

    		def __str__(self):
        
        		# Representaci√≥n en string del objeto (lo que se ve en el admin).
        		return f"{self.nombre} - ${self.precio}"

    		class Meta:
        		verbose_name = "Producto"
        		verbose_name_plural = "Productos"
        		ordering = ['nombre']  # Orden alfab√©tico por nombre.

    		# ============================================================ #
    		# üßâ EXPLICACI√ìN: Este modelo define la estructura de nuestros
    		# productos. Cada campo tiene un tipo espec√≠fico que Django
    		# traduce al tipo de dato correspondiente en la BD.
    		# El m√©todo __str__ es clave para que se vea lindo en el admin.
    		# ============================================================ #

Diagrama UML del modelo Producto:
--------------------------------

Te dejo el gr√°fico en la carpeta UML/ModeloProducto.drawio para que le eches un ojito. üëÄ

Estructura de carpetas despu√©s del paso:
---------------------------------------

Solo modificamos un archivo:

productos/
‚îú‚îÄ‚îÄ models.py          <--- (archivo modificado).
‚îú‚îÄ‚îÄ __init__.py
‚îú‚îÄ‚îÄ admin.py
‚îú‚îÄ‚îÄ apps.py
‚îú‚îÄ‚îÄ migrations/
‚îÇ   ‚îî‚îÄ‚îÄ __init__.py
‚îú‚îÄ‚îÄ tests.py
‚îî‚îÄ‚îÄ views.py

Consejo/curiosidad:
------------------

Fijate que usamos DecimalField para el precio en lugar de FloatField. ¬øPor qu√©? Porque los floats en computaci√≥n tienen problemas de precisi√≥n (0.1 + 0.2 no siempre da 0.3 exacto). Para plata, siempre usamos DecimalField para no descontar de m√°s o de menos. ¬°Plata no se negocia! üí∞


PASO 11: Preparando las valijas para la mudanza (makemigrations) üß≥
===================================================================

Comando ejecutado:
-----------------

	python manage.py makemigrations productos

Explicaci√≥n detallada:
---------------------

makemigrations es como hacer un borrador de los cambios que queremos aplicar en la base de datos. Django inspecciona nuestros modelos, los compara con el estado actual de las migraciones (si las hay) y genera un archivo Python con las instrucciones necesarias para transformar la base de datos. Es como si le dij√©ramos: "Che, cambi√© el plano de la casa, anot√° todos los pasos que hay que hacer para que la casa real se parezca al nuevo plano". üìù

Cuando ejecutamos makemigrations productos, le estamos diciendo: "Solo mir√° la app productos, no las otras". Es m√°s espec√≠fico y evita confusiones.

Lo que se ve en pantalla:
------------------------

	python manage.py makemigrations productos
	Migrations for 'productos':
  		productos/migrations/0001_initial.py
    			- Create model Producto

¬øQu√© archivo se genera y d√≥nde?
-------------------------------

Django crea un archivo en productos/migrations/0001_initial.py. Este archivo contiene c√≥digo Python que describe las operaciones necesarias: CreateModel con todos los campos que definimos. Si lo abr√≠s (no es necesario tocarlo nunca), vas a ver algo como:

	migrations.CreateModel(
    		name='Producto',
    		fields=[
        		('id', models.BigAutoField(...)),  # Django agrega un ID autom√°tico
        		('nombre', models.CharField(...)),
        		('descripcion', models.TextField(...)),
        		# ... etc
    		],
	)

Estructura de carpetas despu√©s del paso:
---------------------------------------

Aparece un nuevo archivo dentro de migrations/:

productos/
‚îî‚îÄ‚îÄ migrations/
    ‚îú‚îÄ‚îÄ __init__.py
    ‚îî‚îÄ‚îÄ 0001_initial.py          <--- Archivo generado autom√°ticamente.

Consejo/curiosidad:
------------------

Los archivos de migraci√≥n son c√≥digo Python com√∫n y corriente. Si quer√©s, pod√©s abrirlos y ver qu√© tienen. Incluso podr√≠as modificarlos (aunque no es recomendable). Cada migraci√≥n tiene un n√∫mero secuencial (0001, 0002, etc.) y depende de las anteriores. Es como un sistema de control de versiones para tu base de datos. üìö


PASO 12: Ejecutando la mudanza (migrate) üöö
===========================================

Comando ejecutado:
-----------------

	python manage.py migrate

Explicaci√≥n detallada:
---------------------

migrate es el que hace el trabajo pesado. Toma todas las migraciones pendientes (los "borradores") y las ejecuta contra la base de datos, creando o modificando tablas, columnas, √≠ndices, etc. Es el momento en que el plano se convierte en casa de verdad. üèóÔ∏è

Cuando ejecut√°s migrate sin especificar una app, Django aplica todas las migraciones pendientes de todas las apps (incluyendo las de Django, como admin y auth). Por eso la primera vez que lo corr√©s, ves que crea un mont√≥n de tablas.

Lo que se ve en pantalla:
------------------------

python manage.py migrate
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, productos, sessions
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying admin.0003_logentry_add_action_flag_choices... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying auth.0008_alter_user_username_max_length... OK
  Applying auth.0009_alter_user_last_name_max_length... OK
  Applying auth.0010_alter_group_name_max_length... OK
  Applying auth.0011_update_proxy_permissions... OK
  Applying auth.0012_alter_user_first_name_max_length... OK
  Applying productos.0001_initial... OK       <--- ¬°Nuestra migraci√≥n!
  Applying sessions.0001_initial... OK

El ciclo MODIFICAR ‚Üí MAKEMIGRATIONS ‚Üí MIGRATE:
---------------------------------------------

Este es el ciclo de vida de los cambios en la base de datos con Django:

1. MODIFICAR: Cambi√°s tus modelos en models.py (agreg√°s un campo, cambi√°s un tipo, cre√°s un modelo nuevo). ‚úèÔ∏è

2. MAKEMIGRATIONS: Gener√°s el "borrador" de los cambios (python manage.py makemigrations). Django crea un archivo con las instrucciones. üìù

3. MIGRATE: Aplic√°s los cambios a la base de datos (python manage.py migrate). Django ejecuta las instrucciones y actualiza el esquema. üöÄ

Es un workflow simple pero poderoso. Pod√©s deshacer cambios, aplicarlos en producci√≥n, compartirlos con otros desarrolladores, etc.

Estructura de carpetas despu√©s del paso:
---------------------------------------

No hay cambios en las carpetas. Pero en la base de datos (db.sqlite3) apareci√≥ una nueva tabla llamada productos_producto (Django nombra las tablas como nombreapp_nombremodelo).

Consejo/curiosidad:
------------------

Si quer√©s ver qu√© tablas se crearon, pod√©s usar un cliente de SQLite (como DB Browser for SQLite) o directamente desde la terminal con:

	sqlite3 db.sqlite3 ".tables"

Vas a ver algo como:

auth_group                  auth_user_user_permissions
auth_group_permissions      django_admin_log
auth_permission             django_content_type
auth_user                   django_migrations
auth_user_groups            django_session
auth_user_user_permissions   productos_producto     <--- Nuestra tabla.


PASO 13: Presentando Producto en el panel de admin üé™
=====================================================

Comando ejecutado:
-----------------

Editamos el archivo productos/admin.py para registrar nuestro modelo.

Explicaci√≥n detallada:
---------------------

Por m√°s que hayamos creado el modelo y la tabla, Django no muestra autom√°ticamente nuestro modelo en el panel de administraci√≥n. Hay que "presentarlo" expl√≠citamente. El archivo admin.py de cada app es donde configuramos c√≥mo se van a ver y comportar nuestros modelos en el admin. Es como decirle: "Che, este modelo Producto quiero poder gestionarlo desde el panel". üéõÔ∏è

C√≥digo en productos/admin.py:
----------------------------

	from django.contrib import admin
	# ‚ûï AGREGADO: Importamos nuestro modelo Producto.
	from .models import Producto

	# Register your models here.

	# ‚ûï AGREGADO: Registramos el modelo para que aparezca en el admin.
	admin.site.register(Producto)

	# ==================================================================== #
	# üßâ EXPLICACI√ìN: Con esta simple l√≠nea, Django agrega autom√°ticamente
	# una interfaz completa para nuestro modelo Producto en el admin.
	# Despu√©s podemos personalizarla con m√°s opciones, pero por ahora con 
	# esto alcanza para empezar a cargar datos.
	# ==================================================================== #

Estructura de carpetas despu√©s del paso:
---------------------------------------

Solo modificamos admin.py:

productos/
‚îú‚îÄ‚îÄ admin.py           <--- (archivo modificado).
‚îú‚îÄ‚îÄ models.py
‚îî‚îÄ‚îÄ ...

Consejo/curiosidad:
------------------

Si quer√©s una personalizaci√≥n r√°pida sin crear clases complejas, pod√©s usar decoradores como @admin.register(Producto) arriba de una clase que herede de admin.ModelAdmin. Pero la l√≠nea simple admin.site.register(Producto) ya te da alta, baja, modificaci√≥n y listado b√°sico. Despu√©s, cuando el proyecto crezca, vas a querer personalizar m√°s. Pero por ahora, ¬°simple es mejor! üéØ


PASO 14: Poblando el mundo con productos üõí
===========================================

Comando ejecutado:
-----------------

1.Asegurate que el servidor est√© corriendo: python manage.py runserver

2. Entr√° a http://127.0.0.1:8000/admin

3. Logueate con admin / Cthulhu

4. En la secci√≥n "Productos", hac√© clic en "Agregar" y carg√° los productos.

Descripci√≥n de c√≥mo se ven los productos en el admin:
----------------------------------------------------

Al entrar al admin, ahora vas a ver una nueva secci√≥n debajo de "Autenticaci√≥n y Autorizaci√≥n" llamada "Productos" (el nombre de nuestra app). Dentro, un enlace a "Productos" (el plural del modelo). Al hacer clic, ves una lista vac√≠a con un bot√≥n naranja arriba a la derecha que dice "AGREGAR PRODUCTO". üçä

Cuando agreg√°s un producto, el formulario muestra todos los campos que definimos (nombre, descripci√≥n, precio, stock). Los campos de fecha se auto-completan, as√≠ que ni los ves (por ahora). Una vez que guard√°s, volv√©s a la lista y ves el producto representado por lo que devuelve el m√©todo __str__: algo como "Yerba Mate Amanda - $5200.00". ¬°Mucho m√°s lindo que ver "Producto object (1)"! üòç

Los 3 productos de ejemplo:
--------------------------

Vamos a cargar la mercader√≠a b√°sica de cualquier despensa que se precie:

1. Yerba Mate üßâ
	+ Nombre: Yerba Mate Amanda
	+ Descripci√≥n: Yerba mate suave con palo, paquete de 1kg
	+ Precio: 5200.00
	+ Stock: 50

2. Dulce de Leche üçØ
	+ Nombre: Dulce de Leche La Seren√≠sima
	+ Descripci√≥n: Cl√°sico repostero, pote de 400g
	+ Precio: 2700.00
	+ Stock: 30

3. Manteca üßà
	+ Nombre: Manteca Tonadita
	+ Descripci√≥n: Manteca con sal, paquete de 200g
	+ Precio: 3200.00
	+ Stock: 25

C√≥mo queda la tabla en la base de datos:
---------------------------------------

Despu√©s de cargar estos productos, la tabla productos_producto en SQLite tiene estos registros (visto desde SQL):

 id	nombre			descripci√≥n		precio		stock	fecha_creacion			fecha_actualizacion
============================================================================================================================================
 1	Yerba Mate Amanda	Yerba mate suave con 	5200.00		50	2026-02-27 10:30:00.123456	2026-02-27 10:30:00.123456
				palo, paquete de 1kg				
					
 2	Dulce de Leche 		Cl√°sico repostero, 	2700.00		30	2026-02-27 10:31:00.123456	2026-02-27 10:31:00.123456
	La Seren√≠sima		pote de 400g
						
 3	Manteca Tonadita	Manteca con sal, 	3200.00		25	2026-02-27 10:32:00.123456	2026-02-27 10:32:00.123456
				paquete de 200g				

Notas:
-----

+ Django agrega autom√°ticamente una columna id como clave primaria (auto-incremental).

+ Los nombres de columna son los mismos que los nombres de campo en el modelo.

+ Las fechas se guardan en la BD en UTC (despu√©s Django las convierte a la zona horaria que configuramos, America/Argentina/Buenos_Aires, cuando las mostramos).

Consejo/curiosidad:
------------------

Fijate que cuando carg√°s un producto en el admin, despu√©s de guardarlo te aparece un mensaje verde diciendo "El producto 'Yerba Mate Amanda - $5200.00' fue agregado correctamente". Ese mensaje usa el __str__ del modelo. Si no hubi√©ramos definido __str__, mostrar√≠a algo horrible como "Producto object (1)". ¬°Los detalles hacen la diferencia! ‚ú®


PASO 15: La vista que trae los datos desde la BD üëÅÔ∏è
===================================================

¬°Llegamos a la recta final de esta primera etapa! Vamos a crear la interfaz visible para el usuario, donde nuestros productos van a salir de la base de datos y mostrarse en el navegador. Esto es lo m√°s parecido a la magia que hace que un backend cobre vida. ‚ú®

Comando ejecutado:
-----------------

Editamos el archivo productos/views.py para crear nuestra primera vista.

Explicaci√≥n detallada:
---------------------

Una vista en Django es una funci√≥n (o clase) que recibe una petici√≥n web (request) y devuelve una respuesta web (response). Es el cerebro que decide qu√© datos hay que buscar, c√≥mo procesarlos y qu√© template usar para mostrarlos. Es como el mozo de un restaurante: toma el pedido (request), va a la cocina (base de datos), busca los platos (productos) y te los sirve en una bandeja (template). üë®‚Äçüç≥

C√≥digo completo en productos/views.py:
-------------------------------------

	from django.shortcuts import render
	# ‚ûï AGREGADO: Importamos el modelo Producto para poder consultar la base de datos.
	from .models import Producto

	# Create your views here.

	def listado_productos(request):
    
    		# Vista que obtiene todos los productos de la base de datos y los env√≠a al 
    		# template para ser mostrados.
    
    		# Flujo de datos:
    		#     1. Recibe un request HTTP
    		#     2. Consulta todos los registros de Producto (SELECT * FROM productos_producto).
    		#     3. Prepara un diccionario con el contexto (los datos a enviar al template).
    		#     4. Renderiza el template 'productos.html' con ese contexto.
    		#     5. Devuelve la respuesta HTTP al navegador.
    
    		# ‚ûï AGREGADO: Obtenemos todos los productos de la base de datos.
    		# Esto ejecuta: SELECT * FROM productos_producto;
    		productos = Producto.objects.all()
    
    		# ‚ûï AGREGADO: Creamos un diccionario con los datos para pasar al template.
    		# La clave 'productos' es la que vamos a usar en el template.
    		contexto = {
        		'productos': productos,
    		}
    
    		# ‚ûï AGREGADO: Renderizamos el template y le pasamos el contexto.
    		return render(request, 'productos.html', contexto)

	# =========================================================================== #
	# üßâ EXPLICACI√ìN: Esta vista es lo m√°s b√°sico que podemos hacer:
	# traer todos los registros de una tabla y mostrarlos.
	# Producto.objects.all() es el equivalente a SELECT * FROM productos_producto.
	# El diccionario 'contexto' es la comunicaci√≥n entre la vista y el template.
	# =========================================================================== #

Estructura de carpetas despu√©s del paso:
---------------------------------------

Modificamos views.py:

productos/
‚îú‚îÄ‚îÄ views.py           <--- (archivo modificado).
‚îú‚îÄ‚îÄ models.py
‚îú‚îÄ‚îÄ admin.py
‚îî‚îÄ‚îÄ ‚Ä¶

Consejo/curiosidad:
------------------

Producto.objects.all() devuelve un QuerySet, que es como una lista superpoderosa de Django. No ejecuta la consulta a la base de datos hasta que realmente la necesit√°s (por ejemplo, cuando iter√°s sobre ella en el template). Esto se llama "evaluaci√≥n perezosa" (lazy evaluation) y ayuda a optimizar el rendimiento. ü¶•


PASO 16: El template que muestra los datos al mundo üåê
======================================================

Comando ejecutado:
-----------------

Primero creamos la carpeta de templates y despu√©s el archivo HTML:

	mkdir -p productos/templates

Luego creamos/editor el archivo productos/templates/productos.html

Explicaci√≥n detallada:
---------------------

Un template es un archivo (generalmente HTML) con placeholders especiales donde Django va a insertar los datos que le pasamos desde la vista. Es como un formulario en blanco donde despu√©s completamos la informaci√≥n con lapicera. üìÑ‚úíÔ∏è

Por convenci√≥n, Django busca templates dentro de una carpeta llamada templates dentro de cada app. As√≠ mantenemos todo organizado.

C√≥digo completo en productos/templates/productos.html:
-----------------------------------------------------

<!DOCTYPE html>
<html lang="es">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Listado de Productos</title>

            {# ‚ûï AGREGADO: Un m√≠nimo de estilo para que no sea tan feo. #}
            <style>
                body 
                    {  font-family: Arial, sans-serif; margin: 40px; }

                h1 
                    {    color: #333; }

                ul 
                    {    list-style: none; padding: 0; }

                li { 
                        background: #f4f4f4; 
                        margin: 10px 0; 
                        padding: 15px; 
                        border-radius: 5px;
                        border-left: 5px solid #007bff;
                    }

                .precio 
                    { 
                        font-weight: bold; 
                        color: #28a745; 
                        font-size: 1.2em;
                    }

                .stock 
                    { 
                        color: #666; 
                        font-size: 0.9em;
                    }
            </style>
    </head>

    <body>
        <h1>üçû Productos disponibles üßà</h1>
        
        {# ‚ûï AGREGADO: Mostramos la lista de productos. #}
            <ul>
                {% comment %}
                # =================================================================== #
                üßâ EXPLICACI√ìN: Esto es un bucle en el lenguaje de templates de Django.
                'productos' es la variable que pasamos desde la vista en el contexto.
                Django itera sobre cada producto y genera un <li> por cada uno.
                Por ahora mostramos la representaci√≥n __str__ del modelo, despu√©s lo 
                vamos a mejorar con detalles lindos.
                # =================================================================== #
                {% endcomment %}

                {% for producto in productos %}
                    <li>
                        <strong>{{ producto }}</strong> 
                         
                        {% comment %}
                        # ============================================== #
                        Mostramos producto.__str__ que definimos antes.
                        Esto es solo para probar, despu√©s vamos a mostrar
                        los campos por separado con m√°s estilo.
                        # ============================================== #
                        {% endcomment %}
                        
                    </li>
                {% empty %}
                    {# ‚ûï AGREGADO: Si no hay productos, mostramos un mensaje. #}
                    <li>No hay productos cargados a√∫n üò¢</li>
                {% endfor %}
            </ul>

        {# ‚ûï AGREGADO: Versi√≥n temporal con representaci√≥n del QuerySet #}
        <h2>üîç Versi√≥n de prueba (solo para desarrolladores):</h2>
        <p>El QuerySet que viene de la base de datos es:</p>
        <pre>{{ productos }}</pre>
        <p><small>üëÜ Esto es un objeto QuerySet, despu√©s vamos a mostrarlo lindo.</small></p>
        
        {% comment %}
        # ================================================================ #
        üßâ EXPLICACI√ìN DEL TEMPLATE: 
        {{ productos }} en el <pre> muestra la representaci√≥n del QuerySet,
        que por ahora es algo como <QuerySet [<Producto: Yerba...>, ...]>.
        Esto es √∫til para debugging, pero NO es lo que ve el usuario final.
        El bucle {% for %} es la forma correcta de mostrar los datos.
        # ================================================================ #
        {% endcomment %}
        
    </body>
</html>

Estructura de carpetas despu√©s del paso:
---------------------------------------

Aparece la carpeta templates con nuestro archivo HTML:

productos/
‚îú‚îÄ‚îÄ templates/             	<--- Carpeta nueva.
‚îÇ   ‚îî‚îÄ‚îÄ productos.html      	<--- Archivo nuevo.
‚îú‚îÄ‚îÄ views.py
‚îú‚îÄ‚îÄ models.py
‚îú‚îÄ‚îÄ admin.py
‚îî‚îÄ‚îÄ ...

Consejo/curiosidad:
------------------

El sistema de templates de Django tiene su propio lenguaje con {% %} para l√≥gica (como for o if) y {{ }} para mostrar variables. Est√° deliberadamente limitado para que no pongas l√≥gica de negocio en el template. Si necesit√°s hacer algo complejo, mejor hacerlo en la vista y pasar el resultado ya procesado. üß†


PASO 17: Conectando la URL con la vista üß≠
==========================================

Comando ejecutado:
-----------------

Editamos el archivo FACTURACION/urls.py (la URL principal del proyecto).

Explicaci√≥n detallada:
---------------------

Las URLs son como el mapa de una ciudad. Cuando alguien escribe una direcci√≥n (ej: /productos/), Django mira en este archivo para saber a qu√© vista tiene que enviar esa petici√≥n. Es el "portero" del edificio: "Ah, vos quer√©s productos? And√° al segundo piso, vista listado_productos". üö™

C√≥digo completo en FACTURACION/urls.py:
--------------------------------------

	from django.contrib import admin
	from django.urls import path
	# ‚úèÔ∏è MODIFICACI√ìN: Importamos la vista que creamos en la app productos.
	from productos.views import listado_productos


	urlpatterns = [
    		path('admin/', admin.site.urls),
    		# ‚ûï AGREGADO: Ruta para ver el listado de productos.
    		# Cuando alguien visite /productos/, Django ejecuta la funci√≥n
    		# listado_productos de productos.views
    		path('productos/', listado_productos, name='listado_productos'),
	]

	# ============================================================== #
	# üßâ EXPLICACI√ìN: Cada entrada en urlpatterns es una ruta.
	# - El primer argumento es el patr√≥n de URL (sin el dominio).
	# - El segundo es la funci√≥n vista a ejecutar.
	# - El tercero (name) es opcional pero muy √∫til para referenciar
	#   esta URL desde otros lugares (templates, redirecciones, etc.)
	# ============================================================== #

Estructura de carpetas despu√©s del paso:
---------------------------------------

Modificamos el archivo de URLs del proyecto:

FACTURACION/
‚îî‚îÄ‚îÄ FACTURACION/
    ‚îî‚îÄ‚îÄ urls.py           <--- (archivo modificado).

Consejo/curiosidad:
------------------

El par√°metro name en las rutas es una buena pr√°ctica. Despu√©s pod√©s hacer {% url 'listado_productos' %} en los templates y aunque cambies la URL (de /productos/ a /catalogo/), todos los enlaces siguen funcionando. Es como tener un acceso directo en lugar de la direcci√≥n exacta. üîó


PASO 18: El momento de la verdad - Verlo en el navegador üéâ
===========================================================

Comando ejecutado:
-----------------

1. Asegurate que el servidor est√© corriendo: python manage.py runserver

2. Abr√≠ el navegador en: http://127.0.0.1:8000/productos/

Explicaci√≥n detallada:
---------------------

¬°Lleg√≥ el momento! Cuando entr√°s a esa URL, pasa todo esto (sin que lo veas):

1. El navegador hace un request a http://127.0.0.1:8000/productos/ üåê

2. Django recibe el request y mira en urls.py üîç

3. Encuentra que productos/ corresponde a listado_productos üéØ

4. Ejecuta la funci√≥n listado_productos en views.py ‚öôÔ∏è

5. La vista consulta la BD: Producto.objects.all() üóÑÔ∏è

6. La vista pasa los productos al template productos.html üì§

7. Django renderiza el template (mezcla HTML con los datos) üé®

8. Devuelve una respuesta HTML al navegador üì®

9. ¬°El navegador muestra la p√°gina! üñ•Ô∏è

Lo que se ve en el navegador:
----------------------------

En la parte superior, vas a ver una lista con los 3 productos que cargamos, mostrando su representaci√≥n __str__:

üçû Productos disponibles üßà

‚Ä¢ Yerba Mate Amanda - $5200.00
‚Ä¢ Dulce de Leche La Seren√≠sima - $2700.00
‚Ä¢ Manteca Tonadita - $3200.00

Y debajo, la secci√≥n de "prueba para desarrolladores" muestra:

üîç Versi√≥n de prueba (solo para desarrolladores):
El QuerySet que viene de la base de datos es:

<QuerySet [<Producto: Yerba Mate Amanda - $5200.00>, 
           <Producto: Dulce de Leche La Seren√≠sima - $2700.00>, 
           <Producto: Manteca Tonadita - $3200.00>]>

Esto √∫ltimo es √∫til para verificar que efectivamente estamos recibiendo los datos, pero obviamente NO es lo que queremos mostrar al usuario final. En el futuro, vamos a reemplazar el {{ producto }} del bucle por algo como:

	<h3>{{ producto.nombre }}</h3>
	<p>{{ producto.descripcion }}</p>
	<span class="precio">${{ producto.precio }}</span>
	<span class="stock">Stock: {{ producto.stock }}</span>

Explicaci√≥n de por qu√© esto es solo una prueba:
----------------------------------------------

Mostrar el QuerySet directamente ({{ productos }}) o solo {{ producto }} (que llama al __str__) es √∫til para desarrolladores porque confirma que los datos est√°n llegando desde la BD hasta el template. Pero para un usuario real, necesitamos un HTML bien formado, con estilos, y mostrando cada campo por separado. Esto es solo el "hilito de tierra" que tiramos para asegurarnos que todo el circuito funciona. Despu√©s viene la parte linda de maquetar. üé®

Diagrama de flujo de una solicitud web:
--------------------------------------

A este diagrama te lo dejo en UML/DiagramaFlujoWeb.drawio üòâ


Estructura final completa del proyecto üìÅ
=========================================

Despu√©s de todos estos pasos, nuestro proyecto tiene esta pinta:

FACTURACION/                  	# Carpeta ra√≠z del proyecto.
‚îú‚îÄ‚îÄ db.sqlite3                	# Base de datos SQLite.
‚îú‚îÄ‚îÄ manage.py                 	# Comandos de Django.
‚îú‚îÄ‚îÄ FACTURACION/             	# Configuraci√≥n del proyecto.
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ settings.py          	# Configuraci√≥n (idioma, apps instaladas).
‚îÇ   ‚îú‚îÄ‚îÄ urls.py               	# URLs principales (admin, productos).
‚îÇ   ‚îî‚îÄ‚îÄ wsgi.py
‚îî‚îÄ‚îÄ productos/                	# Nuestra app.
    ‚îú‚îÄ‚îÄ __init__.py
    ‚îú‚îÄ‚îÄ admin.py              	# Registro del modelo en admin.
    ‚îú‚îÄ‚îÄ apps.py               	# Configuraci√≥n de la app.
    ‚îú‚îÄ‚îÄ models.py              	# Modelo Producto.
    ‚îú‚îÄ‚îÄ tests.py
    ‚îú‚îÄ‚îÄ views.py              	# Vista listado_productos.
    ‚îú‚îÄ‚îÄ migrations/           	# Migraciones de la BD.
    ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
    ‚îÇ   ‚îî‚îÄ‚îÄ 0001_initial.py  	# Migraci√≥n inicial.
    ‚îî‚îÄ‚îÄ templates/            	# Templates HTML.
        ‚îî‚îÄ‚îÄ productos.html    	# Template del listado.


Resumen del flujo completo üöÄ
=============================

1. Modelo (models.py): Definimos la estructura de datos (Producto). üìê

2. Migraciones (makemigrations + migrate): Llevamos esa estructura a la BD. üèóÔ∏è

3. Admin (admin.py): Registramos para poder cargar datos f√°cilmente. üìù

4. Vista (views.py): Creamos la l√≥gica para obtener los datos. üß†

5. Template (templates/productos.html): Dise√±amos c√≥mo se ven. üé®

6. URL (urls.py): Conectamos la URL con la vista. üîó

7. Navegador: El usuario ve el resultado final. üëÄ

¬°Y as√≠, se√±ores, hemos creado nuestro primer circuito completo en Django! Desde la base de datos hasta el navegador, pasando por cada capa de la aplicaci√≥n. Esto es solo el comienzo, pero ya tenemos la base para un sistema de facturaci√≥n que puede crecer hasta donde nos imaginemos. üí™üî•











